class PathFinder {
        
        private Pair<Integer, Integer>[][] all;
        
        private Set<Pair<Integer, Integer>> looked = new HashSet<>();
        private Queue<Pair<Integer, Integer>> q = new LinkedList<>();
        private Map<Pair<Integer, Integer>, Pair<Integer, Integer>> pathTo;
        
        {
            pathTo = new HashMap<>();
            all = new Pair[yBoundTile][xBoundTile];
            for (int y = 0; y < yBoundTile; y++)
                for (int x = 0; x < xBoundTile; x++)
                    all[y][x] = new Pair<>(x, y);
        }
        
        public Stack<Direction> getPath(int xFrom, int yFrom, int xTo, int yTo, DynamicTileActor a) {
            if (a.isObstacle(xTo, yTo))
                throw new RuntimeException();
            Pair<Integer, Integer> from = all[yFrom][xFrom];
            Pair<Integer, Integer> to = all[yTo][xTo];
            q.add(from);
            looked.add(from);
            pathTo.put(from, from);
            while (!q.isEmpty()) {
                Pair<Integer, Integer> v = q.poll();
                if (v.equals(to)) break;
                for (Pair<Integer, Integer> adj : getAdjacentTo(v)) {
                    if (!a.isObstacle(adj.getKey(), adj.getValue()) && !looked.contains(adj)) {
                        q.add(adj);
                        looked.add(adj);
                        pathTo.put(adj, v);
                    }
                }
            }
            Stack<Direction> s = new Stack<>();
            from = pathTo.get(to);
            while (from != to) {
                s.push(getDirection(from, to));
                to = from;
                from = pathTo.get(to);
            }
            return s;
        }
        
        private Pair<Integer, Integer>[] temp = new Pair[4];
        
        private Pair<Integer, Integer>[] getAdjacentTo(Pair<Integer, Integer> v) {
            int x = v.getKey(), y = v.getValue();
            temp[0] = all[(x - 1 + xBoundTile) % xBoundTile][y];
            temp[1] = all[x][(y - 1 + yBoundTile) % yBoundTile];
            temp[2] = all[(x + 1 + xBoundTile) % xBoundTile][y];
            temp[3] = all[x][(y + 1 + yBoundTile) % yBoundTile];
            return temp;
        }
        
        private Direction getDirection(Pair<Integer, Integer> from, Pair<Integer, Integer> to) {
            int xSub = from.getKey() - to.getKey();
            if (xSub != 0) {
                if (xSub == 1) 
                    return Direction.LEFT;
                else 
                    return Direction.RIGHT;
            } else {
                int ySub = from.getValue() - to.getValue();
                if (ySub != 0) {
                    if (ySub == 1)
                        return Direction.TOP;
                    else
                        return Direction.BOTTOM;
                } else 
                    return Direction.NONE;

            }
        }
        
    }